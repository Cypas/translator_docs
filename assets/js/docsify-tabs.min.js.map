{"version":3,"file":"docsify-tabs.min.js","sources":["../node_modules/style-inject/dist/style-inject.es.js","../src/js/index.js"],"sourcesContent":["function styleInject(css, ref) {\n  if ( ref === void 0 ) ref = {};\n  var insertAt = ref.insertAt;\n\n  if (!css || typeof document === 'undefined') { return; }\n\n  var head = document.head || document.getElementsByTagName('head')[0];\n  var style = document.createElement('style');\n  style.type = 'text/css';\n\n  if (insertAt === 'top') {\n    if (head.firstChild) {\n      head.insertBefore(style, head.firstChild);\n    } else {\n      head.appendChild(style);\n    }\n  } else {\n    head.appendChild(style);\n  }\n\n  if (style.styleSheet) {\n    style.styleSheet.cssText = css;\n  } else {\n    style.appendChild(document.createTextNode(css));\n  }\n}\n\nexport default styleInject;\n","// Dependencies\n// =============================================================================\nimport { version as pkgVersion } from '../../package.json';\nimport '../scss/style.scss';\n\n\n// Constants and variables\n// =============================================================================\nconst commentReplaceMark = 'tabs:replace';\nconst classNames = {\n    tabsContainer  : 'content',\n    tabBlock       : 'docsify-tabs',\n    tabButton      : 'docsify-tabs__tab',\n    tabButtonActive: 'docsify-tabs__tab--active',\n    tabContent     : 'docsify-tabs__content'\n};\nconst regex = {\n    // Matches markdown code blocks (inline and multi-line)\n    // Example: ```text```\n    codeMarkup: /(```[\\s\\S]*?```)/gm,\n\n    // Matches tab replacement comment\n    // 0: Match\n    // 1: Replacement HTML\n    commentReplaceMarkup: new RegExp(`<!-- ${commentReplaceMark} (.*) -->`),\n\n    // Matches tab set by start/end comment\n    // 0: Match\n    // 1: Indent\n    // 2: Start comment: <!-- tabs:start -->\n    // 3: Labels and content\n    // 4: End comment: <!-- tabs:end -->\n    tabBlockMarkup: /[\\r\\n]*(\\s*)(<!-+\\s+tabs:\\s*?start\\s+-+>)[\\r\\n]+([\\s|\\S]*?)[\\r\\n\\s]+(<!-+\\s+tabs:\\s*?end\\s+-+>)/m,\n\n    // Matches tab label and content\n    // 0: Match\n    // 1: Label: <!-- tab:Label -->\n    // 2: Content\n    tabCommentMarkup: /[\\r\\n]*(\\s*)<!-+\\s+tab:\\s*(.*)\\s+-+>[\\r\\n]+([\\s\\S]*?)[\\r\\n]*\\s*(?=<!-+\\s+tabs?:(?!replace))/m,\n\n    // Matches tab label and content\n    // 0: Match\n    // 1: Label: #### **Label** OR #### __Label__\n    // 2: Content\n    tabHeadingMarkup: /[\\r\\n]*(\\s*)#{1,6}\\s*[*_]{2}\\s*(.*[^\\s])\\s*[*_]{2}[\\r\\n]+([\\s\\S]*?)(?=#{1,6}\\s*[*_]{2}|<!-+\\s+tabs:\\s*?end\\s+-+>)/m\n};\nconst settings = {\n    persist    : true,\n    sync       : true,\n    theme      : 'classic',\n    tabComments: true,\n    tabHeadings: true\n};\n\n\n// Functions\n// =============================================================================\n/**\n * Traverses the element and its parents until it finds a node that matches the\n * provided selector string. Will return itself or the matching ancestor.\n *\n * @param {object} elm\n * @param {string} closestSelectorString\n * @return {(object|null)}\n */\nfunction getClosest(elm, closestSelectorString) {\n    if (Element.prototype.closest) {\n        return elm.closest(closestSelectorString);\n    }\n\n    while (elm) {\n        const isMatch = matchSelector(elm, closestSelectorString);\n\n        if (isMatch) {\n            return elm;\n        }\n\n        elm = elm.parentNode || null;\n    }\n\n    return elm;\n}\n\n/**\n * Checks to see if the element would be selected by the provided selectorString\n *\n * @param {object} elm\n * @param {string} selectorString\n * @return {boolean}\n */\nfunction matchSelector(elm, selectorString) {\n    const matches = Element.prototype.matches ||\n        Element.prototype.msMatchesSelector ||\n        Element.prototype.webkitMatchesSelector;\n\n    return matches.call(elm, selectorString);\n}\n\n/**\n * Converts tab content into \"stage 1\" markup. Stage 1 markup contains temporary\n * comments which are replaced with HTML during Stage 2. This approach allows\n * all markdown to be converted to HTML before tab-specific HTML is added.\n *\n * @param {string} content\n * @returns {string}\n */\nfunction renderTabsStage1(content, vm) {\n    const codeBlockMatch   = content.match(regex.codeMarkup) || [];\n    const codeBlockMarkers = codeBlockMatch.map((item, i) => {\n        const codeMarker = `<!-- ${commentReplaceMark} CODEBLOCK${i} -->`;\n\n        // Replace code block with marker to ensure tab markup within code\n        // blocks is not processed. These markers are replaced with their\n        // associated code blocs after tabs have been processed.\n        content = content.replace(item, () => codeMarker);\n\n        return codeMarker;\n    });\n    const tabTheme = settings.theme ? `${classNames.tabBlock}--${settings.theme}` : '';\n    const tempElm  = document.createElement('div');\n\n    let tabIndex = 1;\n    let tabBlockMatch; // eslint-disable-line no-unused-vars\n    let tabMatch; // eslint-disable-line no-unused-vars\n\n    // Process each tab set\n    while ((tabBlockMatch = regex.tabBlockMarkup.exec(content)) !== null) {\n        let tabBlock            = tabBlockMatch[0];\n        let tabStartReplacement = '';\n        let tabEndReplacement   = '';\n\n        const hasTabComments = settings.tabComments && regex.tabCommentMarkup.test(tabBlock);\n        const hasTabHeadings = settings.tabHeadings && regex.tabHeadingMarkup.test(tabBlock);\n        const tabBlockIndent = tabBlockMatch[1];\n        const tabBlockStart  = tabBlockMatch[2];\n        const tabBlockEnd    = tabBlockMatch[4];\n\n        if (hasTabComments || hasTabHeadings) {\n            tabStartReplacement = `<!-- ${commentReplaceMark} <div class=\"${[classNames.tabBlock, tabTheme].join(' ')}\"> -->`;\n            tabEndReplacement = `\\n${tabBlockIndent}<!-- ${commentReplaceMark} </div> -->`;\n\n            // Process each tab panel\n            while ((tabMatch = (settings.tabComments ? regex.tabCommentMarkup.exec(tabBlock) : null) || (settings.tabHeadings ? regex.tabHeadingMarkup.exec(tabBlock) : null)) !== null) {\n                // Process tab title as markdown\n                // Ex: <!-- tab:**Bold** and <span style=\"color: red;\">red</span> -->\n                tempElm.innerHTML = tabMatch[2].trim() ? vm.compiler.compile(tabMatch[2]).replace(/<\\/?p>/g, '') : `Tab ${tabIndex}`;\n\n                const tabTitle = tempElm.innerHTML;\n                const tabContent = (tabMatch[3] || '').trim();\n                const tabData = (\n                    tempElm.textContent ||\n                    (tempElm.firstChild.getAttribute('alt') || tempElm.firstChild.getAttribute('src'))\n                ).trim().toLowerCase();\n\n                // Use replace function to avoid regex special replacement\n                // strings being processed ($$, $&, $`, $', $n)\n                tabBlock = tabBlock.replace(tabMatch[0], () => [\n                    `\\n${tabBlockIndent}<!-- ${commentReplaceMark} <button class=\"${classNames.tabButton}\" data-tab=\"${tabData}\">${tabTitle}</button> -->`,\n                    `\\n${tabBlockIndent}<!-- ${commentReplaceMark} <div class=\"${classNames.tabContent}\" data-tab-content=\"${tabData}\"> -->`,\n                    `\\n\\n${tabBlockIndent}${tabContent}`,\n                    `\\n\\n${tabBlockIndent}<!-- ${commentReplaceMark} </div> -->`,\n                ].join(''));\n\n                tabIndex++;\n            }\n        }\n\n        tabBlock = tabBlock.replace(tabBlockStart, () => tabStartReplacement);\n        tabBlock = tabBlock.replace(tabBlockEnd, () => tabEndReplacement);\n        content = content.replace(tabBlockMatch[0], () => tabBlock);\n    }\n\n    // Restore code blocks\n    codeBlockMarkers.forEach((item, i) => {\n        content = content.replace(item, () => codeBlockMatch[i]);\n    });\n\n    return content;\n}\n\n/**\n * Converts \"stage 1\" markup into final markup by replacing temporary comments\n * with HTML.\n *\n * @param {string} html\n * @returns {string}\n */\nfunction renderTabsStage2(html) {\n    let tabReplaceMatch; // eslint-disable-line no-unused-vars\n\n    while ((tabReplaceMatch = regex.commentReplaceMarkup.exec(html)) !== null) {\n        const tabComment     = tabReplaceMatch[0];\n        const tabReplacement = tabReplaceMatch[1] || '';\n\n        html = html.replace(tabComment, () => tabReplacement);\n    }\n\n    return html;\n}\n\n/**\n * Sets the initial active tab for each tab group: the tab containing the\n * matching element ID from the URL, the first tab in the group, or the last tab\n * clicked (if persist option is enabled).\n */\nfunction setDefaultTabs() {\n    const tabsContainer     = document.querySelector(`.${classNames.tabsContainer}`);\n    const tabBlocks         = tabsContainer ? Array.apply(null, tabsContainer.querySelectorAll(`.${classNames.tabBlock}`)) : [];\n    const tabStoragePersist = JSON.parse(sessionStorage.getItem(window.location.href)) || {};\n    const tabStorageSync    = JSON.parse(sessionStorage.getItem('*')) || [];\n\n    setActiveTabFromAnchor();\n\n    tabBlocks.forEach((tabBlock, index) => {\n        let activeButton = tabBlock.querySelector(`.${classNames.tabButtonActive}`);\n\n        if (!activeButton) {\n            if (settings.sync && tabStorageSync.length) {\n                activeButton = tabStorageSync\n                    .map(label => tabBlock.querySelector(`.${classNames.tabButton}[data-tab=\"${label}\"]`))\n                    .filter(elm => elm)[0];\n            }\n\n            if (!activeButton && settings.persist) {\n                activeButton = tabBlock.querySelector(`.${classNames.tabButton}[data-tab=\"${tabStoragePersist[index]}\"]`);\n            }\n\n            activeButton = activeButton || tabBlock.querySelector(`.${classNames.tabButton}`);\n            activeButton && activeButton.classList.add(classNames.tabButtonActive);\n        }\n    });\n}\n\n/**\n * Sets the active tab within a group. Optionally stores the selection so it can\n * persist across page loads and syncs active state to tabs with same data attr.\n *\n * @param {object} elm Tab toggle element to mark as active\n */\nfunction setActiveTab(elm, _isMatchingTabSync = false) {\n    const activeButton = getClosest(elm, `.${classNames.tabButton}`);\n\n    if (activeButton) {\n        const activeButtonLabel = activeButton.getAttribute('data-tab');\n        const tabsContainer     = document.querySelector(`.${classNames.tabsContainer}`);\n        const tabBlock          = activeButton.parentNode;\n        const tabButtons        = Array.apply(null, tabBlock.querySelectorAll(`.${classNames.tabButton}`));\n        const tabBlockOffset    = tabBlock.offsetTop;\n\n        tabButtons.forEach(buttonElm => buttonElm.classList.remove(classNames.tabButtonActive));\n        activeButton.classList.add(classNames.tabButtonActive);\n\n        if (!_isMatchingTabSync) {\n            if (settings.persist) {\n                const tabBlocks     = tabsContainer ? Array.apply(null, tabsContainer.querySelectorAll(`.${classNames.tabBlock}`)) : [];\n                const tabBlockIndex = tabBlocks.indexOf(tabBlock);\n                const tabStorage    = JSON.parse(sessionStorage.getItem(window.location.href)) || {};\n\n                tabStorage[tabBlockIndex] = activeButtonLabel;\n                sessionStorage.setItem(window.location.href, JSON.stringify(tabStorage));\n            }\n\n            if (settings.sync) {\n                const tabButtonMatches = tabsContainer ? Array.apply(null, tabsContainer.querySelectorAll(`.${classNames.tabButton}[data-tab=\"${activeButtonLabel}\"]`)) : [];\n                const tabStorage       = JSON.parse(sessionStorage.getItem('*')) || [];\n\n                tabButtonMatches.forEach(tabButtonMatch => {\n                    setActiveTab(tabButtonMatch, true);\n                });\n\n                // Maintain position in viewport when tab group's offset changes\n                window.scrollBy(0, 0 - (tabBlockOffset - tabBlock.offsetTop));\n\n                // Remove existing label if not first in array\n                if (tabStorage.indexOf(activeButtonLabel) > 0) {\n                    tabStorage.splice(tabStorage.indexOf(activeButtonLabel), 1);\n                }\n\n                // Add label if not already in first position\n                if (tabStorage.indexOf(activeButtonLabel) !== 0) {\n                    tabStorage.unshift(activeButtonLabel);\n                    sessionStorage.setItem('*', JSON.stringify(tabStorage));\n                }\n            }\n        }\n    }\n}\n\n/**\n * Sets the active tab based on the anchor ID in the URL\n */\nfunction setActiveTabFromAnchor() {\n    const anchorID              = decodeURIComponent((window.location.hash.match(/(?:id=)([^&]+)/) || [])[1]);\n    const anchorSelector        = anchorID && `.${classNames.tabBlock} #${anchorID}`;\n    const isAnchorElmInTabBlock = anchorID && document.querySelector(anchorSelector);\n\n    if (isAnchorElmInTabBlock) {\n        const anchorElm = document.querySelector(`#${anchorID}`);\n\n        let tabContent;\n\n        if (anchorElm.closest) {\n            tabContent = anchorElm.closest(`.${classNames.tabContent}`);\n        }\n        else {\n            tabContent = anchorElm.parentNode;\n\n            while (tabContent !== document.body && !tabContent.classList.contains(`${classNames.tabContent}`)) {\n                tabContent = tabContent.parentNode;\n            }\n        }\n\n        setActiveTab(tabContent.previousElementSibling);\n    }\n}\n\n\n// Plugin\n// =============================================================================\nfunction docsifyTabs(hook, vm) {\n    let hasTabs = false;\n\n    hook.beforeEach(function(content) {\n        hasTabs = regex.tabBlockMarkup.test(content);\n\n        if (hasTabs) {\n            content = renderTabsStage1(content, vm);\n        }\n\n        return content;\n    });\n\n    hook.afterEach(function(html, next) {\n        if (hasTabs) {\n            html = renderTabsStage2(html);\n        }\n\n        next(html);\n    });\n\n    hook.doneEach(function() {\n        if (hasTabs) {\n            setDefaultTabs();\n        }\n    });\n\n    hook.mounted(function() {\n        const tabsContainer = document.querySelector(`.${classNames.tabsContainer}`);\n\n        tabsContainer && tabsContainer.addEventListener('click', function handleTabClick(evt) {\n            setActiveTab(evt.target);\n        });\n\n        window.addEventListener('hashchange', setActiveTabFromAnchor, false);\n    });\n}\n\n\nif (window) {\n    window.$docsify = window.$docsify || {};\n\n    // Add config object\n    window.$docsify.tabs = window.$docsify.tabs || {};\n\n    // Update settings based on $docsify config\n    Object.keys(window.$docsify.tabs).forEach(key => {\n        if (Object.prototype.hasOwnProperty.call(settings, key)) {\n            settings[key] = window.$docsify.tabs[key];\n        }\n    });\n\n    // Add plugin data\n    window.$docsify.tabs.version = pkgVersion;\n\n    // Init plugin\n    if (settings.tabComments || settings.tabHeadings) {\n        window.$docsify.plugins = [].concat(\n            docsifyTabs,\n            (window.$docsify.plugins || [])\n        );\n    }\n}\n"],"names":["css","ref","insertAt","document","head","getElementsByTagName","style","createElement","type","firstChild","insertBefore","appendChild","styleSheet","cssText","createTextNode","commentReplaceMark","classNames","tabsContainer","tabBlock","tabButton","tabButtonActive","tabContent","regex","codeMarkup","commentReplaceMarkup","RegExp","tabBlockMarkup","tabCommentMarkup","tabHeadingMarkup","settings","persist","sync","theme","tabComments","tabHeadings","getClosest","elm","closestSelectorString","Element","prototype","closest","matchSelector","parentNode","selectorString","matches","msMatchesSelector","webkitMatchesSelector","call","setActiveTab","_isMatchingTabSync","activeButton","activeButtonLabel","getAttribute","querySelector","tabButtons","Array","apply","querySelectorAll","tabBlockOffset","offsetTop","forEach","buttonElm","classList","remove","add","tabBlocks","tabBlockIndex","indexOf","tabStorage","JSON","parse","sessionStorage","getItem","window","location","href","setItem","stringify","tabButtonMatches","tabButtonMatch","scrollBy","splice","unshift","setActiveTabFromAnchor","anchorID","decodeURIComponent","hash","match","anchorSelector","anchorElm","body","contains","previousElementSibling","$docsify","tabs","Object","keys","key","hasOwnProperty","version","plugins","concat","hook","vm","hasTabs","beforeEach","content","test","tabBlockMatch","tabMatch","codeBlockMatch","codeBlockMarkers","map","item","i","codeMarker","replace","tabTheme","tempElm","tabIndex","tabStartReplacement","tabEndReplacement","hasTabComments","hasTabHeadings","tabBlockIndent","tabBlockStart","tabBlockEnd","join","innerHTML","trim","compiler","compile","tabTitle","tabData","textContent","toLowerCase","exec","renderTabsStage1","afterEach","html","next","tabReplaceMatch","tabComment","tabReplacement","renderTabsStage2","doneEach","tabStoragePersist","tabStorageSync","index","length","label","filter","mounted","addEventListener","evt","target"],"mappings":"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"}